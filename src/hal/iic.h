/***************************************************************************//**
 \file iic.h
 \date created on: 21.01.2018
 \author Nick Egorrov
 \defgroup IIC <iic.h> : Шина IIC
 Этот модуль обеспечивает обмен с переферийными устройствами по шине I2C в
 режиме мастера.
 Работу с шиной  можно условно разделить на три группы:
 - \ref IIC_COMMON
 - \ref IIC_LOW
 - \ref IIC_HIGH
 ******************************************************************************/

#ifndef SRC_HAL_IIC_H_
#define SRC_HAL_IIC_H_

#include <stdint.h>

#include "../config.h"

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************//**
 \addtogroup IIC
 \section IIC_COMMON Общие функции
 Эти функции используются и с низкоуровневыми и с высокоуровневыми функциями и
 позволяют установить и получить адрес устройства, получить код ошибки и при
 необходимости сбросить ошибку.
 @{
 ******************************************************************************/

/**
 *  Default IIC clock frequency in hertz
 */
#ifndef CFG_IIC_FREQUENSY
#define CFG_IIC_FREQUENSY 10000
#warning Use default CFG_IIC_FREQUENSY
#endif

/**
 * Время ожидания ответа от устройства в миллисекундах.
 */
#define IIC_TIMEOUT 50

/**
 * \brief Ошибки модуля.
 */
typedef enum {
        /** Нет ошибок. */
        IIC_NO_ERROR,
        /** Неизвестная ошибка. */
        IIC_UNKNOWN_ERROR,
        /** Ошибка при генерации состояния старт. */
        IIC_ERROR_START,
        /** Ошибка при передаче адреса. */
        IIC_ERROR_ADDR,
        /** Ошибка при записи. */
        IIC_ERROR_WRITE,
        /** Ошибка при чтении. */
        IIC_ERROR_READ,
        /** Ошибка при генерации состояния стоп. */
        IIC_ERROR_STOP,
        /** Устройство не отвечает */
        IIC_ERROR_WAIT = 0x80
} iic_error_t;

typedef enum {
        IIC_WRITE=0,
        IIC_READ
}iic_mode_t;

/**
 * \brief Инициализация модуля.
 * \details
 */
extern void iic_init(void);

/**
 * \brief Устанавливает адрес устройства.
 * \details Адрес сохраняется во внутренней переменной и затем используется
 *      функцией iic_ll_start() для подготовки шины к обмену.
 * \param adr адрес устройства. Младший бит игнорируется.
 */
extern void iic_set_address(uint8_t adr);

/**
 * \brief Получение адреса устройства.
 * \details
 * \return адрес устройства.
 */
extern uint8_t iic_get_address(void);

/**
 * \brief Получение кода ошибки модуля.
 * \details
 * \return код ошибки.
 */
extern iic_error_t iic_error(void);

/**
 * \brief Сброс ошибки модуля.
 * \details
 */
extern void iic_clear(void);

/** @} */

/***************************************************************************//**
 \addtogroup IIC
 \section IIC_LOW Низкоуровневые функции

 @{
 ******************************************************************************/

/**
 * Выставляет на шину состояние старт/рестарт и адрес устройства. Адрес должен
 *      быть задан функцией iic_set_address().
 * \param mode Режим обмена шины.
 */
extern void iic_ll_start(iic_mode_t mode);

/**
 * Завершение обмена и генерация состояния стоп.
 */
extern void iic_ll_stop(void);

/**
 * \brief Чтение байта.
 * \details Перед первым вызовом этой функции необходимо подготовить шину
 *      вызвав iic_ll_start() с ненулевым агрументом.
 * \param last ноль если требуется считать байт и завершить обмен по шине и не
 *      нулевое значение если требуется считать серию байт.
 * \return Полученный байт.
 */
extern uint8_t iic_ll_read(uint8_t last);

/**
 * \brief Запись байта.
 * \details Перед первым вызовом этой функции необходимо подготовить шину
 *      вызвав iic_ll_start() с нулевым агрументом.
 * \param d Передаваемый байт.
 */
extern void iic_ll_write(uint8_t d);

extern void iic_ll_aread(uint8_t output[], uint8_t rSz);

extern void iic_ll_awrite(uint8_t input[], uint8_t wSz);

/** @} */

/***************************************************************************//**
 \addtogroup IIC
 \section IIC_HIGH Высокоуровневые функции

 @{
 ******************************************************************************/

/**
 * \brief Запись байта в устройство.
 * \details Перед вызовом необходимо убедиться, что функция iic_error() возвращает
 * #IIC_NO_ERROR. В ином случае нужно вызвать iic_clear().
 * Адрес устройства можно изменить функцией iic_set_address(uint8_t adr).
 * \param data Байт для записи в устройство.
 */
extern void iic_write(uint8_t data);

/**
 * \brief Чтение байта из устройства.
 * \details Перед вызовом необходимо убедиться, что функция iic_error() возвращает
 * #IIC_NO_ERROR. В ином случае нужно вызвать iic_clear().
 * Адрес устройства можно изменить функцией iic_set_address(uint8_t adr).
 * \return Байт данных из устройства.
 */
extern uint8_t iic_read(void);

/**
 * \brief Запись команды и чтение байта.
 * \param cmd Команда, посылаемая в устройство.
 * \return Считанный байт.
 */
uint8_t iic_cmd_read(uint8_t cmd);

/**
 * \brief Запись команды и байта.
 * \param cmd Команда, посылаемая в устройство.
 * \param d Записываемый байт.
 */
void iic_cmd_write(uint8_t cmd, uint8_t d);

/**
 * \brief Запись команды и чтение массива.
 * \details Запись команды и последующее чтение массива из устройства.
 * \param cmd Команда, посылаемая в устройство.
 * \param output Массив для считываемых данных. Если равен нулю, то чтения
 *      не происходит.
 * \param rSz Количество считываемых байт. Если равен нулю, то чтения
 *      не происходит.
 */
void iic_cmd_aread(uint8_t cmd, uint8_t output[], uint8_t rSz);

/**
 * \brief Запись команды и запись массива.
 * \details Запись команды и последующая запись массива в устройство.
 * \param cmd Команда, посылаемая в устройство.
 * \param input Массив для записываемых данных. Если равен нулю, то записи
 *      не происходит.
 * \param wSz Количество записываемых байт. Если равен нулю, то записи
 *      не происходит.
 */
void iic_cmd_awrite(uint8_t cmd, uint8_t input[], uint8_t wSz);

/**
 * \brief Запись и чтение массивов.
 * \details Запись и последующее чтение массивов из/в устройство. Поскольку
 * сначала происходит запись, то, при необходимости, считывание можно
 * производить в тот же буфер.
 * \param input Массив с данными для записи. Если равен нулю, то записи
 *      не происходит.
 * \param wSz Количество записываемых данных. Если равен нулю, то записи
 *      не происходит.
 * \param output Массив для считываемых данных. Если равен нулю, то записи
 *      не происходит.
 * \param rSz Количество считываемых байт. Если равен нулю, то записи
 *      не происходит.
 */
void iic_awrite_aread(uint8_t input[], uint8_t wSz, uint8_t output[], uint8_t rSz);

/** @} */

#ifdef __cplusplus
}
#endif

#endif /* SRC_HAL_IIC_H_ */
